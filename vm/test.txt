TAGSIZE 130
LOAD_CONSTANT [1] tm
LOAD_GLOBAL [2] globals  
CALL 0
NOTIN
POP_JUMP_ON_FALSE 0
TAG 1
DICT 0
STORE_GLOBAL [6] Token
TM_DEF 46
LOAD_GLOBAL [6] Token  
LOAD_CONSTANT [13] __init__
SET
TM_DEF 30
LOAD_GLOBAL [6] Token  
LOAD_CONSTANT [17] show
SET
TM_DEF 22
LOAD_GLOBAL [6] Token  
LOAD_CONSTANT [18] __str__
SET
TM_DEF 149
STORE_GLOBAL [35] u_error
LOAD_CONSTANT [36] `-=[];,./~!@$%^&*()+{}:<>?
STORE_GLOBAL [37] ISYMBOLS
LOAD_CONSTANT [38] def
LOAD_CONSTANT [39] class
LOAD_CONSTANT [40] yield
LOAD_CONSTANT [41] return
LOAD_CONSTANT [42] pass
LOAD_CONSTANT [43] and
LOAD_CONSTANT [44] or
LOAD_CONSTANT [45] not
LOAD_CONSTANT [46] in
LOAD_CONSTANT [47] import
LOAD_CONSTANT [48] is
LOAD_CONSTANT [49] while
LOAD_CONSTANT [50] break
LOAD_CONSTANT [51] for
LOAD_CONSTANT [52] continue
LOAD_CONSTANT [53] if
LOAD_CONSTANT [54] else
LOAD_CONSTANT [55] elif
LOAD_CONSTANT [56] try
LOAD_CONSTANT [57] except
LOAD_CONSTANT [58] raise
LOAD_CONSTANT [59] global
LOAD_CONSTANT [60] del
LOAD_CONSTANT [61] from
LOAD_CONSTANT [8] None
LOAD_CONSTANT [62] -
LOAD_CONSTANT [63] +
LOAD_CONSTANT [5] *
LOAD_CONSTANT [64] **
LOAD_CONSTANT [65] /
LOAD_CONSTANT [66] %
LOAD_CONSTANT [67] <<
LOAD_CONSTANT [68] >>
LOAD_CONSTANT [69] -=
LOAD_CONSTANT [70] +=
LOAD_CONSTANT [71] *=
LOAD_CONSTANT [72] /=
LOAD_CONSTANT [73] =
LOAD_CONSTANT [74] ==
LOAD_CONSTANT [75] !=
LOAD_CONSTANT [76] <
LOAD_CONSTANT [77] >
LOAD_CONSTANT [78] <=
LOAD_CONSTANT [79] >=
LOAD_CONSTANT [80] [
LOAD_CONSTANT [81] ]
LOAD_CONSTANT [82] {
LOAD_CONSTANT [83] }
LOAD_CONSTANT [84] (
LOAD_CONSTANT [85] )
LOAD_CONSTANT [86] .
LOAD_CONSTANT [87] :
LOAD_CONSTANT [88] ,
LOAD_CONSTANT [89] ;
LOAD_CONSTANT [90] &
LOAD_CONSTANT [91] |
LOAD_CONSTANT [92] !
LIST 57
STORE_GLOBAL [93] SYMBOLS
LOAD_CONSTANT [80] [
LOAD_CONSTANT [84] (
LOAD_CONSTANT [82] {
LIST 3
STORE_GLOBAL [94] B_BEGIN
LOAD_CONSTANT [81] ]
LOAD_CONSTANT [85] )
LOAD_CONSTANT [83] }
LIST 3
STORE_GLOBAL [95] B_END
DICT 0
STORE_GLOBAL [96] TData
TM_DEF 57
LOAD_GLOBAL [96] TData  
LOAD_CONSTANT [13] __init__
SET
TM_DEF 159
LOAD_GLOBAL [96] TData  
LOAD_CONSTANT [108] add
SET
TM_DEF 37
STORE_GLOBAL [112] clean
TM_DEF 11
STORE_GLOBAL [113] tokenize
TM_DEF 619
STORE_GLOBAL [140] do_tokenize
TM_DEF 82
STORE_GLOBAL [121] do_nl
TM_DEF 138
STORE_GLOBAL [120] do_indent
TM_DEF 182
STORE_GLOBAL [101] indent
TM_DEF 278
STORE_GLOBAL [122] do_symbol
TM_DEF 279
STORE_GLOBAL [125] do_number
TM_DEF 220
STORE_GLOBAL [131] do_name
TM_DEF 515
STORE_GLOBAL [134] do_string
TM_DEF 66
STORE_GLOBAL [136] do_comment
LOAD_GLOBAL [156] __name__  
LOAD_CONSTANT [157] __main__
EQEQ
POP_JUMP_ON_FALSE 126
LOAD_GLOBAL [158] load  
LOAD_CONSTANT [159] tokenize.py
CALL 1
STORE_GLOBAL [141] v
LOAD_GLOBAL [113] tokenize  
LOAD_GLOBAL [141] v  
CALL 1
PARAMS END
LOAD_GLOBAL [112] clean  
LOAD_LOCAL 0
CALL 1
PARAMS END
LOAD_LOCAL 0
LOAD_CONSTANT [109] replace
GET
LOAD_CONSTANT [110] 

LOAD_CONSTANT [22] 

CALL 2
step0
\r\n
\n
25
49
51
65
123
175
225
246
296
320
363
365
388
401
432
444
469
496
537
571
603
605
646
659
734
803
855
896
944
1011
1018
1043
1066
1068
1082
1107
1152
1193
1248
1299
1324
1347
1382
1418
1478
1497
1536
1588
1603
1651
1653
1668
1700
1730
1744
1746
1764
1782
1811
1843
1882
1884
1905
1919
1951
1987
2013
2031
2071
2090
2116
2150
2192
2242
2300
2343
2413
2466
2510
2554
2592
2636
2677
2692
2717
2731
2733
2752
2774
2800
2825
2846
2872
2892
2906
2908
2931
2942
2958
2976
3018
3043
3062
3121
3135
3137
3153
3185
3213
3241
3268
3296
3327
3363
3395
3426
3428
3430
3453
3471
3497
3518
3558
3574
3592
3629
3654
3673
3717
3761
3777
3813
3847
3861
3863
3886
3914
3938
3954
3972
4050
4075
4094
4112
4137
4156
4176
4198
4240
4269
4292
4315
4329
4331
4352
4369
4385
4403
4506
4526
4559
4586
4600
4602
4625
4651
4707
4723
4745
4767
4823
4847
4882
4905
4924
4952
5000
5011
5031
5053
5080
5115
5154
5196
5235
5274
5301
5327
5351
5386
5409
5428
5455
5469
5471
5495
5507
5523
5541
5570
5586
5600
5602
5630
5659
5680
5698
5738
5740
step1
step2
if "tm" not in globals():\r\n    from boot import *\r\n\r\nclass Token:\r\n    def __init__(self,type='symbol',val=None,pos=(0,0)):\r\n        # self.pos,self.type,self.val=pos,type,val\r\n        self.pos=pos;self.type=type;self.val=val\r\n    def show(self):\r\n        print(self.type +' => ' + str(self.val))\r\n    def __str__(self):\r\n        return str([self.type, self.val])\r\n\r\ndef u_error(ctx,s,i):\r\n    y,x = i\r\n    line = s.split('\n')[y-1]\r\n    p = ''\r\n    if y < 10: p += ' '\r\n    if y < 100: p += '  '\r\n    r = p + str(y) + ": " + line + "\n"\r\n    r += "     "+" "*x+"^" +'\n'\r\n    raise 'error: '+ctx+'\n'+r\r\n\r\nISYMBOLS = '`-=[];,./~!@$%^&*()+{}:<>?'\r\nSYMBOLS = [\r\n    'def','class','yield','return','pass','and','or','not','in','import',\r\n    'is','while','break','for','continue','if','else','elif','try',\r\n    'except','raise','global','del','from','None',\r\n    '-','+','*','**','/','%','<<','>>',\r\n    '-=','+=','*=','/=','=','==','!=','<','>',\r\n    '<=','>=','[',']','{','}','(',')','.',':',',',';','&','|','!'\r\n    ]\r\nB_BEGIN = ['[','(','{']\r\nB_END = [']',')','}']\r\n\r\nclass TData:\r\n    def __init__(self):\r\n        # self.y,self.yi,self.nl = 1,0,True\r\n        self.y=1;self.yi=0;self.nl=True\r\n        # self.res,self.indent,self.braces = [],[0],0\r\n        self.res=[];self.indent=[0];self.braces=0\r\n    def add(self,t,v): \r\n        if t == 'in':\r\n            last = self.res.pop()\r\n            if last.type == 'not':\r\n                self.res.append(Token('notin', v, self.f))\r\n            else:\r\n                self.res.append(last)\r\n                self.res.append(Token(t,v,self.f))\r\n        else:\r\n            self.res.append(Token(t,v,self.f))\r\n\r\ndef clean(s):\r\n    s = s.replace('\r\n','\n')\r\n    s = s.replace('\r','\n')\r\n    return s\r\n\r\ndef tokenize(s):\r\n    s = clean(s)\r\n    # return do_tokenize(s)\r\n    try: return do_tokenize(s)\r\n    except: u_error('tokenize',s,T.f)\r\n\r\ndef do_tokenize(s):\r\n    global T\r\n    # T,i,l = TData(),0,len(s)\r\n    T = TData(); i = 0; l = len(s)\r\n    T.f = (T.y,i-T.yi+1)\r\n    while i < l:\r\n        c = s[i]; T.f = (T.y,i-T.yi+1)\r\n        if T.nl: \r\n            T.nl = False\r\n            i = do_indent(s,i,l)\r\n        elif c == '\n': i = do_nl(s,i,l)\r\n        elif c in ISYMBOLS: i = do_symbol(s,i,l)\r\n        elif c >= '0' and c <= '9': i = do_number(s,i,l)\r\n        elif (c >= 'a' and c <= 'z') or \\r\n            (c >= 'A' and c <= 'Z') or c == '_':  i = do_name(s,i,l)\r\n        elif c=='"' or c=="'": i = do_string(s,i,l)\r\n        elif c=='#': i = do_comment(s,i,l)\r\n        elif c == '\\' and s[i+1] == '\n':\r\n            i += 2; T.y+=1; T.yi = i\r\n        elif c == ' ' or c == '\t': i += 1\r\n        else: u_error('tokenize',s,T.f)\r\n    indent(0)\r\n    r = T.res; T = None\r\n    return r\r\n\r\ndef do_nl(s,i,l):\r\n    if not T.braces:\r\n        T.add('nl','nl')\r\n    # i,T.nl = i+1,True\r\n    i+=1; T.nl=True\r\n    # T.y,T.yi = T.y+1,i\r\n    T.y+=1; T.yi=i\r\n    return i\r\n\r\ndef do_indent(s,i,l):\r\n    v = 0\r\n    while i<l:\r\n        c = s[i]\r\n        if c != ' ' and c != '\t': break\r\n        # i,v = i+1,v+1\r\n        i+=1;v+=1\r\n    if c != '\n' and c != '#' and not T.braces: indent(v)\r\n    return i\r\n\r\ndef indent(v):\r\n    if v == T.indent[-1]: pass\r\n    elif v > T.indent[-1]:\r\n        T.indent.append(v)\r\n        T.add('indent',v)\r\n    elif v < T.indent[-1]:\r\n        n = T.indent.index(v)\r\n        while len(T.indent) > n+1:\r\n            v = T.indent.pop()\r\n            T.add('dedent',v)\r\n\r\n\r\ndef do_symbol(s,i,l):\r\n    symbols = []\r\n    # v,f,i = s[i],i,i+1\r\n    v=s[i];f=i;i+=1\r\n    if v in SYMBOLS: symbols.append(v)\r\n    while i<l:\r\n        c = s[i]\r\n        if not c in ISYMBOLS: break\r\n        # v,i = v+c,i+1\r\n        v+=c;i+=1\r\n        if v in SYMBOLS: symbols.append(v)\r\n    v = symbols.pop(); n = len(v); i = f+n\r\n    T.add(v,v)\r\n    if v in B_BEGIN: T.braces += 1\r\n    if v in B_END: T.braces -= 1\r\n    return i\r\n\r\ndef do_number(s,i,l):\r\n    # v,i,c =s[i],i+1,s[i]\r\n    v=s[i];i+=1;c=s[i]\r\n    while i<l:\r\n        c = s[i]\r\n        if (c < '0' or c > '9') and (c < 'a' or c > 'f') and c != 'x': break\r\n        # v,i = v+c,i+1\r\n        v+=c;i+=1\r\n    if c == '.':\r\n        # v,i = v+c,i+1\r\n        v+=c;i+=1\r\n        while i<l:\r\n            c = s[i]\r\n            if c < '0' or c > '9': break\r\n            # v,i = v+c,i+1\r\n            v+=c;i+=1\r\n    T.add('number',v)\r\n    return i\r\n\r\ndef do_name(s,i,l):\r\n    v=s[i];i+=1\r\n    while i<l:\r\n        c = s[i]\r\n        if (c < 'a' or c > 'z') and (c < 'A' or c > 'Z') and (c < '0' or c > '9') and c != '_': break\r\n        v+=c; i+=1\r\n    if v in SYMBOLS: T.add(v,v)\r\n    else: T.add('name',v)\r\n    return i\r\n\r\ndef do_string(s,i,l):\r\n    v = ''; q=s[i]; i+=1\r\n    if (l-i) >= 5 and s[i] == q and s[i+1] == q: # """\r\n        i += 2\r\n        while i<l-2:\r\n            c = s[i]\r\n            if c == q and s[i+1] == q and s[i+2] == q:\r\n                i += 3\r\n                T.add('string',v)\r\n                break\r\n            else:\r\n                v+=c; i+=1\r\n                if c == '\n': T.y += 1;T.x = i\r\n    else:\r\n        while i<l:\r\n            c = s[i]\r\n            if c == "\\":\r\n                i = i+1; c = s[i]\r\n                if c == "n": c = '\n'\r\n                if c == "r": c = chr(13)\r\n                if c == "t": c = "\t"\r\n                if c == "0": c = "\0"\r\n                v+=c;i+=1\r\n            elif c == q:\r\n                i += 1\r\n                T.add('string',v)\r\n                break\r\n            else:\r\n                v+=c;i+=1\r\n    return i\r\n\r\ndef do_comment(s,i,l):\r\n    i += 1\r\n    while i<l:\r\n        c = s[i]\r\n        if c == '\n': break\r\n        i += 1\r\n    return i\r\n\r\nif __name__ == "__main__":\r\n    v = load("tokenize.py")\r\n    r = tokenize(v)\r\n    for tk in r:\r\n        print(tk.type, tk.pos, tk.val)\r\n\r\n
if "tm" not in globals():\n    from boot import *\n\nclass Token:\n    def __init__(self,type='symbol',val=None,pos=(0,0)):\n        # self.pos,self.type,self.val=pos,type,val\n        self.pos=pos;self.type=type;self.val=val\n    def show(self):\n        print(self.type +' => ' + str(self.val))\n    def __str__(self):\n        return str([self.type, self.val])\n\ndef u_error(ctx,s,i):\n    y,x = i\n    line = s.split('\n')[y-1]\n    p = ''\n    if y < 10: p += ' '\n    if y < 100: p += '  '\n    r = p + str(y) + ": " + line + "\n"\n    r += "     "+" "*x+"^" +'\n'\n    raise 'error: '+ctx+'\n'+r\n\nISYMBOLS = '`-=[];,./~!@$%^&*()+{}:<>?'\nSYMBOLS = [\n    'def','class','yield','return','pass','and','or','not','in','import',\n    'is','while','break','for','continue','if','else','elif','try',\n    'except','raise','global','del','from','None',\n    '-','+','*','**','/','%','<<','>>',\n    '-=','+=','*=','/=','=','==','!=','<','>',\n    '<=','>=','[',']','{','}','(',')','.',':',',',';','&','|','!'\n    ]\nB_BEGIN = ['[','(','{']\nB_END = [']',')','}']\n\nclass TData:\n    def __init__(self):\n        # self.y,self.yi,self.nl = 1,0,True\n        self.y=1;self.yi=0;self.nl=True\n        # self.res,self.indent,self.braces = [],[0],0\n        self.res=[];self.indent=[0];self.braces=0\n    def add(self,t,v): \n        if t == 'in':\n            last = self.res.pop()\n            if last.type == 'not':\n                self.res.append(Token('notin', v, self.f))\n            else:\n                self.res.append(last)\n                self.res.append(Token(t,v,self.f))\n        else:\n            self.res.append(Token(t,v,self.f))\n\ndef clean(s):\n    s = s.replace('\r\n','\n')\n    s = s.replace('\r','\n')\n    return s\n\ndef tokenize(s):\n    s = clean(s)\n    # return do_tokenize(s)\n    try: return do_tokenize(s)\n    except: u_error('tokenize',s,T.f)\n\ndef do_tokenize(s):\n    global T\n    # T,i,l = TData(),0,len(s)\n    T = TData(); i = 0; l = len(s)\n    T.f = (T.y,i-T.yi+1)\n    while i < l:\n        c = s[i]; T.f = (T.y,i-T.yi+1)\n        if T.nl: \n            T.nl = False\n            i = do_indent(s,i,l)\n        elif c == '\n': i = do_nl(s,i,l)\n        elif c in ISYMBOLS: i = do_symbol(s,i,l)\n        elif c >= '0' and c <= '9': i = do_number(s,i,l)\n        elif (c >= 'a' and c <= 'z') or \\n            (c >= 'A' and c <= 'Z') or c == '_':  i = do_name(s,i,l)\n        elif c=='"' or c=="'": i = do_string(s,i,l)\n        elif c=='#': i = do_comment(s,i,l)\n        elif c == '\\' and s[i+1] == '\n':\n            i += 2; T.y+=1; T.yi = i\n        elif c == ' ' or c == '\t': i += 1\n        else: u_error('tokenize',s,T.f)\n    indent(0)\n    r = T.res; T = None\n    return r\n\ndef do_nl(s,i,l):\n    if not T.braces:\n        T.add('nl','nl')\n    # i,T.nl = i+1,True\n    i+=1; T.nl=True\n    # T.y,T.yi = T.y+1,i\n    T.y+=1; T.yi=i\n    return i\n\ndef do_indent(s,i,l):\n    v = 0\n    while i<l:\n        c = s[i]\n        if c != ' ' and c != '\t': break\n        # i,v = i+1,v+1\n        i+=1;v+=1\n    if c != '\n' and c != '#' and not T.braces: indent(v)\n    return i\n\ndef indent(v):\n    if v == T.indent[-1]: pass\n    elif v > T.indent[-1]:\n        T.indent.append(v)\n        T.add('indent',v)\n    elif v < T.indent[-1]:\n        n = T.indent.index(v)\n        while len(T.indent) > n+1:\n            v = T.indent.pop()\n            T.add('dedent',v)\n\n\ndef do_symbol(s,i,l):\n    symbols = []\n    # v,f,i = s[i],i,i+1\n    v=s[i];f=i;i+=1\n    if v in SYMBOLS: symbols.append(v)\n    while i<l:\n        c = s[i]\n        if not c in ISYMBOLS: break\n        # v,i = v+c,i+1\n        v+=c;i+=1\n        if v in SYMBOLS: symbols.append(v)\n    v = symbols.pop(); n = len(v); i = f+n\n    T.add(v,v)\n    if v in B_BEGIN: T.braces += 1\n    if v in B_END: T.braces -= 1\n    return i\n\ndef do_number(s,i,l):\n    # v,i,c =s[i],i+1,s[i]\n    v=s[i];i+=1;c=s[i]\n    while i<l:\n        c = s[i]\n        if (c < '0' or c > '9') and (c < 'a' or c > 'f') and c != 'x': break\n        # v,i = v+c,i+1\n        v+=c;i+=1\n    if c == '.':\n        # v,i = v+c,i+1\n        v+=c;i+=1\n        while i<l:\n            c = s[i]\n            if c < '0' or c > '9': break\n            # v,i = v+c,i+1\n            v+=c;i+=1\n    T.add('number',v)\n    return i\n\ndef do_name(s,i,l):\n    v=s[i];i+=1\n    while i<l:\n        c = s[i]\n        if (c < 'a' or c > 'z') and (c < 'A' or c > 'Z') and (c < '0' or c > '9') and c != '_': break\n        v+=c; i+=1\n    if v in SYMBOLS: T.add(v,v)\n    else: T.add('name',v)\n    return i\n\ndef do_string(s,i,l):\n    v = ''; q=s[i]; i+=1\n    if (l-i) >= 5 and s[i] == q and s[i+1] == q: # """\n        i += 2\n        while i<l-2:\n            c = s[i]\n            if c == q and s[i+1] == q and s[i+2] == q:\n                i += 3\n                T.add('string',v)\n                break\n            else:\n                v+=c; i+=1\n                if c == '\n': T.y += 1;T.x = i\n    else:\n        while i<l:\n            c = s[i]\n            if c == "\\":\n                i = i+1; c = s[i]\n                if c == "n": c = '\n'\n                if c == "r": c = chr(13)\n                if c == "t": c = "\t"\n                if c == "0": c = "\0"\n                v+=c;i+=1\n            elif c == q:\n                i += 1\n                T.add('string',v)\n                break\n            else:\n                v+=c;i+=1\n    return i\n\ndef do_comment(s,i,l):\n    i += 1\n    while i<l:\n        c = s[i]\n        if c == '\n': break\n        i += 1\n    return i\n\nif __name__ == "__main__":\n    v = load("tokenize.py")\n    r = tokenize(v)\n    for tk in r:\n        print(tk.type, tk.pos, tk.val)\n\n
STORE_LOCAL 0
LOAD_LOCAL 0
LOAD_CONSTANT [109] replace
GET
LOAD_CONSTANT [111] 
LOAD_CONSTANT [22] 

CALL 2
step0
\r
\n
step1
step2
if "tm" not in globals():\n    from boot import *\n\nclass Token:\n    def __init__(self,type='symbol',val=None,pos=(0,0)):\n        # self.pos,self.type,self.val=pos,type,val\n        self.pos=pos;self.type=type;self.val=val\n    def show(self):\n        print(self.type +' => ' + str(self.val))\n    def __str__(self):\n        return str([self.type, self.val])\n\ndef u_error(ctx,s,i):\n    y,x = i\n    line = s.split('\n')[y-1]\n    p = ''\n    if y < 10: p += ' '\n    if y < 100: p += '  '\n    r = p + str(y) + ": " + line + "\n"\n    r += "     "+" "*x+"^" +'\n'\n    raise 'error: '+ctx+'\n'+r\n\nISYMBOLS = '`-=[];,./~!@$%^&*()+{}:<>?'\nSYMBOLS = [\n    'def','class','yield','return','pass','and','or','not','in','import',\n    'is','while','break','for','continue','if','else','elif','try',\n    'except','raise','global','del','from','None',\n    '-','+','*','**','/','%','<<','>>',\n    '-=','+=','*=','/=','=','==','!=','<','>',\n    '<=','>=','[',']','{','}','(',')','.',':',',',';','&','|','!'\n    ]\nB_BEGIN = ['[','(','{']\nB_END = [']',')','}']\n\nclass TData:\n    def __init__(self):\n        # self.y,self.yi,self.nl = 1,0,True\n        self.y=1;self.yi=0;self.nl=True\n        # self.res,self.indent,self.braces = [],[0],0\n        self.res=[];self.indent=[0];self.braces=0\n    def add(self,t,v): \n        if t == 'in':\n            last = self.res.pop()\n            if last.type == 'not':\n                self.res.append(Token('notin', v, self.f))\n            else:\n                self.res.append(last)\n                self.res.append(Token(t,v,self.f))\n        else:\n            self.res.append(Token(t,v,self.f))\n\ndef clean(s):\n    s = s.replace('\r\n','\n')\n    s = s.replace('\r','\n')\n    return s\n\ndef tokenize(s):\n    s = clean(s)\n    # return do_tokenize(s)\n    try: return do_tokenize(s)\n    except: u_error('tokenize',s,T.f)\n\ndef do_tokenize(s):\n    global T\n    # T,i,l = TData(),0,len(s)\n    T = TData(); i = 0; l = len(s)\n    T.f = (T.y,i-T.yi+1)\n    while i < l:\n        c = s[i]; T.f = (T.y,i-T.yi+1)\n        if T.nl: \n            T.nl = False\n            i = do_indent(s,i,l)\n        elif c == '\n': i = do_nl(s,i,l)\n        elif c in ISYMBOLS: i = do_symbol(s,i,l)\n        elif c >= '0' and c <= '9': i = do_number(s,i,l)\n        elif (c >= 'a' and c <= 'z') or \\n            (c >= 'A' and c <= 'Z') or c == '_':  i = do_name(s,i,l)\n        elif c=='"' or c=="'": i = do_string(s,i,l)\n        elif c=='#': i = do_comment(s,i,l)\n        elif c == '\\' and s[i+1] == '\n':\n            i += 2; T.y+=1; T.yi = i\n        elif c == ' ' or c == '\t': i += 1\n        else: u_error('tokenize',s,T.f)\n    indent(0)\n    r = T.res; T = None\n    return r\n\ndef do_nl(s,i,l):\n    if not T.braces:\n        T.add('nl','nl')\n    # i,T.nl = i+1,True\n    i+=1; T.nl=True\n    # T.y,T.yi = T.y+1,i\n    T.y+=1; T.yi=i\n    return i\n\ndef do_indent(s,i,l):\n    v = 0\n    while i<l:\n        c = s[i]\n        if c != ' ' and c != '\t': break\n        # i,v = i+1,v+1\n        i+=1;v+=1\n    if c != '\n' and c != '#' and not T.braces: indent(v)\n    return i\n\ndef indent(v):\n    if v == T.indent[-1]: pass\n    elif v > T.indent[-1]:\n        T.indent.append(v)\n        T.add('indent',v)\n    elif v < T.indent[-1]:\n        n = T.indent.index(v)\n        while len(T.indent) > n+1:\n            v = T.indent.pop()\n            T.add('dedent',v)\n\n\ndef do_symbol(s,i,l):\n    symbols = []\n    # v,f,i = s[i],i,i+1\n    v=s[i];f=i;i+=1\n    if v in SYMBOLS: symbols.append(v)\n    while i<l:\n        c = s[i]\n        if not c in ISYMBOLS: break\n        # v,i = v+c,i+1\n        v+=c;i+=1\n        if v in SYMBOLS: symbols.append(v)\n    v = symbols.pop(); n = len(v); i = f+n\n    T.add(v,v)\n    if v in B_BEGIN: T.braces += 1\n    if v in B_END: T.braces -= 1\n    return i\n\ndef do_number(s,i,l):\n    # v,i,c =s[i],i+1,s[i]\n    v=s[i];i+=1;c=s[i]\n    while i<l:\n        c = s[i]\n        if (c < '0' or c > '9') and (c < 'a' or c > 'f') and c != 'x': break\n        # v,i = v+c,i+1\n        v+=c;i+=1\n    if c == '.':\n        # v,i = v+c,i+1\n        v+=c;i+=1\n        while i<l:\n            c = s[i]\n            if c < '0' or c > '9': break\n            # v,i = v+c,i+1\n            v+=c;i+=1\n    T.add('number',v)\n    return i\n\ndef do_name(s,i,l):\n    v=s[i];i+=1\n    while i<l:\n        c = s[i]\n        if (c < 'a' or c > 'z') and (c < 'A' or c > 'Z') and (c < '0' or c > '9') and c != '_': break\n        v+=c; i+=1\n    if v in SYMBOLS: T.add(v,v)\n    else: T.add('name',v)\n    return i\n\ndef do_string(s,i,l):\n    v = ''; q=s[i]; i+=1\n    if (l-i) >= 5 and s[i] == q and s[i+1] == q: # """\n        i += 2\n        while i<l-2:\n            c = s[i]\n            if c == q and s[i+1] == q and s[i+2] == q:\n                i += 3\n                T.add('string',v)\n                break\n            else:\n                v+=c; i+=1\n                if c == '\n': T.y += 1;T.x = i\n    else:\n        while i<l:\n            c = s[i]\n            if c == "\\":\n                i = i+1; c = s[i]\n                if c == "n": c = '\n'\n                if c == "r": c = chr(13)\n                if c == "t": c = "\t"\n                if c == "0": c = "\0"\n                v+=c;i+=1\n            elif c == q:\n                i += 1\n                T.add('string',v)\n                break\n            else:\n                v+=c;i+=1\n    return i\n\ndef do_comment(s,i,l):\n    i += 1\n    while i<l:\n        c = s[i]\n        if c == '\n': break\n        i += 1\n    return i\n\nif __name__ == "__main__":\n    v = load("tokenize.py")\n    r = tokenize(v)\n    for tk in r:\n        print(tk.type, tk.pos, tk.val)\n\n
if "tm" not in globals():\n    from boot import *\n\nclass Token:\n    def __init__(self,type='symbol',val=None,pos=(0,0)):\n        # self.pos,self.type,self.val=pos,type,val\n        self.pos=pos;self.type=type;self.val=val\n    def show(self):\n        print(self.type +' => ' + str(self.val))\n    def __str__(self):\n        return str([self.type, self.val])\n\ndef u_error(ctx,s,i):\n    y,x = i\n    line = s.split('\n')[y-1]\n    p = ''\n    if y < 10: p += ' '\n    if y < 100: p += '  '\n    r = p + str(y) + ": " + line + "\n"\n    r += "     "+" "*x+"^" +'\n'\n    raise 'error: '+ctx+'\n'+r\n\nISYMBOLS = '`-=[];,./~!@$%^&*()+{}:<>?'\nSYMBOLS = [\n    'def','class','yield','return','pass','and','or','not','in','import',\n    'is','while','break','for','continue','if','else','elif','try',\n    'except','raise','global','del','from','None',\n    '-','+','*','**','/','%','<<','>>',\n    '-=','+=','*=','/=','=','==','!=','<','>',\n    '<=','>=','[',']','{','}','(',')','.',':',',',';','&','|','!'\n    ]\nB_BEGIN = ['[','(','{']\nB_END = [']',')','}']\n\nclass TData:\n    def __init__(self):\n        # self.y,self.yi,self.nl = 1,0,True\n        self.y=1;self.yi=0;self.nl=True\n        # self.res,self.indent,self.braces = [],[0],0\n        self.res=[];self.indent=[0];self.braces=0\n    def add(self,t,v): \n        if t == 'in':\n            last = self.res.pop()\n            if last.type == 'not':\n                self.res.append(Token('notin', v, self.f))\n            else:\n                self.res.append(last)\n                self.res.append(Token(t,v,self.f))\n        else:\n            self.res.append(Token(t,v,self.f))\n\ndef clean(s):\n    s = s.replace('\r\n','\n')\n    s = s.replace('\r','\n')\n    return s\n\ndef tokenize(s):\n    s = clean(s)\n    # return do_tokenize(s)\n    try: return do_tokenize(s)\n    except: u_error('tokenize',s,T.f)\n\ndef do_tokenize(s):\n    global T\n    # T,i,l = TData(),0,len(s)\n    T = TData(); i = 0; l = len(s)\n    T.f = (T.y,i-T.yi+1)\n    while i < l:\n        c = s[i]; T.f = (T.y,i-T.yi+1)\n        if T.nl: \n            T.nl = False\n            i = do_indent(s,i,l)\n        elif c == '\n': i = do_nl(s,i,l)\n        elif c in ISYMBOLS: i = do_symbol(s,i,l)\n        elif c >= '0' and c <= '9': i = do_number(s,i,l)\n        elif (c >= 'a' and c <= 'z') or \\n            (c >= 'A' and c <= 'Z') or c == '_':  i = do_name(s,i,l)\n        elif c=='"' or c=="'": i = do_string(s,i,l)\n        elif c=='#': i = do_comment(s,i,l)\n        elif c == '\\' and s[i+1] == '\n':\n            i += 2; T.y+=1; T.yi = i\n        elif c == ' ' or c == '\t': i += 1\n        else: u_error('tokenize',s,T.f)\n    indent(0)\n    r = T.res; T = None\n    return r\n\ndef do_nl(s,i,l):\n    if not T.braces:\n        T.add('nl','nl')\n    # i,T.nl = i+1,True\n    i+=1; T.nl=True\n    # T.y,T.yi = T.y+1,i\n    T.y+=1; T.yi=i\n    return i\n\ndef do_indent(s,i,l):\n    v = 0\n    while i<l:\n        c = s[i]\n        if c != ' ' and c != '\t': break\n        # i,v = i+1,v+1\n        i+=1;v+=1\n    if c != '\n' and c != '#' and not T.braces: indent(v)\n    return i\n\ndef indent(v):\n    if v == T.indent[-1]: pass\n    elif v > T.indent[-1]:\n        T.indent.append(v)\n        T.add('indent',v)\n    elif v < T.indent[-1]:\n        n = T.indent.index(v)\n        while len(T.indent) > n+1:\n            v = T.indent.pop()\n            T.add('dedent',v)\n\n\ndef do_symbol(s,i,l):\n    symbols = []\n    # v,f,i = s[i],i,i+1\n    v=s[i];f=i;i+=1\n    if v in SYMBOLS: symbols.append(v)\n    while i<l:\n        c = s[i]\n        if not c in ISYMBOLS: break\n        # v,i = v+c,i+1\n        v+=c;i+=1\n        if v in SYMBOLS: symbols.append(v)\n    v = symbols.pop(); n = len(v); i = f+n\n    T.add(v,v)\n    if v in B_BEGIN: T.braces += 1\n    if v in B_END: T.braces -= 1\n    return i\n\ndef do_number(s,i,l):\n    # v,i,c =s[i],i+1,s[i]\n    v=s[i];i+=1;c=s[i]\n    while i<l:\n        c = s[i]\n        if (c < '0' or c > '9') and (c < 'a' or c > 'f') and c != 'x': break\n        # v,i = v+c,i+1\n        v+=c;i+=1\n    if c == '.':\n        # v,i = v+c,i+1\n        v+=c;i+=1\n        while i<l:\n            c = s[i]\n            if c < '0' or c > '9': break\n            # v,i = v+c,i+1\n            v+=c;i+=1\n    T.add('number',v)\n    return i\n\ndef do_name(s,i,l):\n    v=s[i];i+=1\n    while i<l:\n        c = s[i]\n        if (c < 'a' or c > 'z') and (c < 'A' or c > 'Z') and (c < '0' or c > '9') and c != '_': break\n        v+=c; i+=1\n    if v in SYMBOLS: T.add(v,v)\n    else: T.add('name',v)\n    return i\n\ndef do_string(s,i,l):\n    v = ''; q=s[i]; i+=1\n    if (l-i) >= 5 and s[i] == q and s[i+1] == q: # """\n        i += 2\n        while i<l-2:\n            c = s[i]\n            if c == q and s[i+1] == q and s[i+2] == q:\n                i += 3\n                T.add('string',v)\n                break\n            else:\n                v+=c; i+=1\n                if c == '\n': T.y += 1;T.x = i\n    else:\n        while i<l:\n            c = s[i]\n            if c == "\\":\n                i = i+1; c = s[i]\n                if c == "n": c = '\n'\n                if c == "r": c = chr(13)\n                if c == "t": c = "\t"\n                if c == "0": c = "\0"\n                v+=c;i+=1\n            elif c == q:\n                i += 1\n                T.add('string',v)\n                break\n            else:\n                v+=c;i+=1\n    return i\n\ndef do_comment(s,i,l):\n    i += 1\n    while i<l:\n        c = s[i]\n        if c == '\n': break\n        i += 1\n    return i\n\nif __name__ == "__main__":\n    v = load("tokenize.py")\n    r = tokenize(v)\n    for tk in r:\n        print(tk.type, tk.pos, tk.val)\n\n
STORE_LOCAL 0
LOAD_LOCAL 0
RETURN
STORE_LOCAL 0
TM_EOF
STORE_GLOBAL [32] r
LOAD_GLOBAL [32] r  
LOAD_CONSTANT [9] 0
TAG 128
TM_FOR 129
Traceback (most recent call last):
  File "tk": None
Exception: tm_len:  has no attribute len
